Ответы на теоретические вопросы

Q1

При сравнении разных типов не строгим равенством происходит приведение операндов к числу, 
что может дать не совсем нужный результат. Например:
'' == 0 // true
0 == false // true

При строгом равенстве === учитывается тип операндов, исключая данные сюрпризы.

Q2

Загрузку скриптов помещают в конец тега body для того, чтобы загрузка скриптов 
не блокировала отрисовку страницы. Однако существуют атрибуты defer и async для решения
это проблемы. 
Многие относятся к этому со скепсисом тк какой толк от отрисованной страницы если ее
поведение еще не загружено и это только раздражает, другие их парируют тем что за пару 
секунд предзагруженной страницы можно понять нужен ли тебе данный сайт или нет, можно уйти 
не дожидаясь окончательной загрузки. Философский вопрос.

Q3

В js можно организовать наследование в функциональном и прототипном стиле.
Функциональное наследование выглядит так:
function Animal(num) {
	var age = num;
		this.getAge = function() {
		return age;
	};
	
	this.setAge = function(num) {
		age = num;
	}
}

function Human(age, name) {
	Animal.apply(this, arguments);
	
	this.work = function() {
		//do someth..
	};

	this.name = name;
}

var human = new Human(26, 'Артем');

Объект human будет наследовать от Animal публичные методы get/setAge, 
а так же приватную переменную age, правда к переменной age не будет доступа из 
метода work, т.к. приватная переменная живет в замыкании функций get/setAge.

Наследование в прототипном стиле предыдущего примера будет иметь такой вид:

function Animal(age) {
	this.age = age;
};

Animal.prototype.getAge = function() {
	return this.age;
};

Animal.prototype.setAge = function(num) {
	this.age = num;
};

function Human(age, name) {
	Animal.apply(this, arguments);
	this.name = name;
};

Human.prototype = Object.create(Animal.prototype);
Human.prototype.constructor = Human;

Human.prototype.work = function() {
	// do someth...
};

var human = new Human(26, 'Артем');

Недостатком прототипного наследования является отсуствие приватных переменных.

Тонким моментом в прототипном наследовании является то что поиск свойства(метода) 
сначала происходит в объекте, а затем если свойство не найдено поднимаемся вверх по прототипу 
пока не найдем нужное нам свойство. Однако если мы запишем что нибудь в это 
свойство(примитив) то оно запишется в объект не трогая родительский прототип в дальнейшем 
при обращении, поиск в прототипе происходить не будет. Если же мы обращаемся не к примитиву 
а объекту, и перезаписываем отдельный элемент то обновляется родительский объект(в прототипе), перезапись 
у себя в объекте не происходит.

В нашем проекте в основном используется прототипное наследование. Так же очень часто 
бывает необходимо унаследовать что то от двух классов, в данном случае пользуемся примесями.

Q4

Благодаря синтаксису controllerAs при вложенных друг в друга контроллерах мы можем 
четко знать из какого именно контроллера мы берем переменную. Тк scope прототипно наследует 
вышестоящий родительский scope, это может привести к неочевидным результатам(перезапись родительских примитивов).

Q5

Может понадобиться при использовании сторонних для ангуляра модулей, в том числе 
и нативных js типа Promise, setTimeout, для обновления данных. Всегда рекомендуется 
использовать встроенные в ангуляр модули типа $q, $timeout, или $http, они 
работают практически аналогично нативным js, Promise, setTimeout, но с запуском digest цикла.